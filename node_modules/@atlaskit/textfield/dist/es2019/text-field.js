import _extends from "@babel/runtime/helpers/extends";

/** @jsx jsx */
import React, { forwardRef, memo, useCallback, useMemo, useRef } from 'react';
import { jsx } from '@emotion/core';
import { usePlatformLeafEventHandler } from '@atlaskit/analytics-next';
import GlobalTheme from '@atlaskit/theme/components';
import { containerStyles as getContainerStyles, inputStyles as getInputStyles } from './styles';
const analyticsParams = {
  componentName: 'textField',
  packageName: "@atlaskit/textfield",
  packageVersion: "5.0.1"
};
const TextfieldWithMode = /*#__PURE__*/forwardRef((props, ref) => {
  const input = useRef(null);
  const {
    appearance = 'standard',
    isCompact = false,
    isDisabled = false,
    isInvalid = false,
    isRequired = false,
    isReadOnly = false,
    isMonospaced = false,
    width,
    mode,
    elemAfterInput,
    elemBeforeInput,
    testId,
    onFocus,
    onBlur,
    onMouseDown,
    className,
    ...otherProps
  } = props;
  const handleOnFocus = usePlatformLeafEventHandler({
    fn: event => {
      onFocus && onFocus(event);
    },
    action: 'focused',
    ...analyticsParams
  });
  const handleOnBlur = usePlatformLeafEventHandler({
    fn: event => {
      onBlur && onBlur(event);
    },
    action: 'blurred',
    ...analyticsParams
  });
  const handleOnMouseDown = useCallback(event => {
    /** Running e.preventDefault() on the INPUT prevents double click behaviour */
    // Sadly we needed this cast as the target type is being correctly set
    const target = event.target;

    if (target.tagName !== 'INPUT') {
      event.preventDefault();
    }

    if (input && input.current && !isDisabled && document.activeElement !== input.current) {
      input.current.focus();
    }

    onMouseDown && onMouseDown(event);
  }, [onMouseDown, input, isDisabled]); // we want to keep a copy of the ref as well as pass it along

  const setInputRef = useCallback(inputElement => {
    input.current = inputElement;
    const forwardedRef = ref;

    if (!forwardedRef) {
      return;
    }

    if (typeof forwardedRef === 'object') {
      // This is a blunder on the part of @types/react
      // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/31065
      // .current should be assignable
      // @ts-ignore
      forwardedRef.current = inputElement;
    }

    if (typeof forwardedRef === 'function') {
      forwardedRef(inputElement);
    }
  }, [ref]);
  const inputControlProps = {
    'data-compact': isCompact ? isCompact : undefined,
    'data-monospaced': isMonospaced ? isMonospaced : undefined,
    'aria-invalid': isInvalid ? isInvalid : undefined
  };
  const containerControlProps = {
    'data-disabled': isDisabled ? isDisabled : undefined,
    'data-invalid': isInvalid ? isInvalid : undefined
  };
  const containerStyles = useMemo(() => getContainerStyles(appearance, mode, width), [appearance, mode, width]);
  const inputStyle = useMemo(() => getInputStyles(mode), [mode]);
  return (// https://product-fabric.atlassian.net/browse/DST-1970
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions
    jsx("div", _extends({}, containerControlProps, {
      onMouseDown: handleOnMouseDown,
      "data-ds--text-field--container": true,
      "data-testid": testId && `${testId}-container`,
      css: containerStyles,
      className: className
    }), elemBeforeInput, jsx("input", _extends({}, otherProps, inputControlProps, {
      disabled: isDisabled,
      readOnly: isReadOnly,
      required: isRequired,
      onBlur: handleOnBlur,
      onFocus: handleOnFocus,
      ref: setInputRef,
      "data-ds--text-field--input": true,
      "data-testid": testId,
      css: inputStyle
    })), elemAfterInput)
  );
});
const Textfield = /*#__PURE__*/forwardRef(function Textfield(props, ref) {
  return jsx(GlobalTheme.Consumer, null, ({
    mode
  }) => jsx(TextfieldWithMode, _extends({}, props, {
    mode: mode,
    ref: ref
  })));
});
Textfield.displayName = 'Textfield';
export default /*#__PURE__*/memo(Textfield);