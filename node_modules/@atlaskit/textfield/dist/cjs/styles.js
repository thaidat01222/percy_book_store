"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TextFieldColors = exports.inputStyles = exports.containerStyles = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _constants = require("@atlaskit/theme/constants");

var componentTokens = _interopRequireWildcard(require("./component-tokens"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var fontSize = (0, _constants.fontSize)();
var gridSize = (0, _constants.gridSize)();
var disabledRules = {
  light: {
    backgroundColor: componentTokens.defaultBackgroundColor.light,
    backgroundColorFocus: componentTokens.disabledBackgroundColor.light,
    backgroundColorHover: componentTokens.disabledBackgroundColor.light,
    // same as bg, appears as no border
    borderColor: componentTokens.defaultBackgroundColor.light,
    borderColorFocus: componentTokens.defaultBorderColorFocus.light,
    textColor: componentTokens.disabledTextColor.light
  },
  dark: {
    backgroundColor: componentTokens.defaultBackgroundColor.dark,
    backgroundColorFocus: componentTokens.disabledBackgroundColor.dark,
    backgroundColorHover: componentTokens.disabledBackgroundColor.dark,
    // same as bg, appears as no border
    borderColor: componentTokens.defaultBackgroundColor.dark,
    borderColorFocus: componentTokens.defaultBorderColorFocus.dark,
    textColor: componentTokens.disabledTextColor.dark
  }
};
var invalidRules = {
  light: {
    backgroundColor: componentTokens.defaultBackgroundColor.light,
    backgroundColorFocus: componentTokens.defaultBackgroundColorFocus.light,
    backgroundColorHover: componentTokens.defaultBackgroundColorHover.light,
    borderColor: componentTokens.invalidBorderColor.light,
    borderColorFocus: componentTokens.defaultBorderColorFocus.light
  },
  dark: {
    backgroundColor: componentTokens.defaultBackgroundColor.dark,
    backgroundColorFocus: componentTokens.defaultBackgroundColorFocus.dark,
    backgroundColorHover: componentTokens.defaultBackgroundColorHover.dark,
    borderColor: componentTokens.invalidBorderColor.dark,
    borderColorFocus: componentTokens.defaultBorderColorFocus.dark
  }
};
var backgroundColor = {
  standard: componentTokens.defaultBackgroundColor,
  subtle: componentTokens.transparent,
  none: componentTokens.transparent
};
var backgroundColorFocus = {
  standard: componentTokens.defaultBackgroundColorFocus,
  subtle: componentTokens.defaultBackgroundColorFocus,
  none: componentTokens.transparent
};
var backgroundColorHover = {
  standard: componentTokens.defaultBackgroundColorHover,
  subtle: componentTokens.defaultBackgroundColorHover,
  none: componentTokens.transparent
};
var borderColor = {
  standard: componentTokens.defaultBorderColor,
  subtle: componentTokens.transparent,
  none: componentTokens.transparent
};
var borderColorFocus = {
  standard: componentTokens.defaultBorderColorFocus,
  subtle: componentTokens.defaultBorderColorFocus,
  none: componentTokens.transparent
};

var getContainerTextBgAndBorderColor = function getContainerTextBgAndBorderColor(appearance, mode) {
  return {
    backgroundColor: backgroundColor[appearance][mode],
    borderColor: borderColor[appearance][mode],
    color: componentTokens.textColor[mode],
    cursor: 'text',
    '&:hover': {
      backgroundColor: backgroundColorHover[appearance][mode]
    },
    '&:focus-within': {
      backgroundColor: backgroundColorFocus[appearance][mode],
      borderColor: borderColorFocus[appearance][mode]
    },
    '&[data-disabled]': {
      backgroundColor: disabledRules[mode].backgroundColor,
      borderColor: disabledRules[mode].borderColor,
      color: disabledRules[mode].textColor,
      cursor: 'not-allowed'
    },
    '&[data-disabled]:focus-within': {
      backgroundColor: disabledRules[mode].backgroundColorFocus,
      borderColor: disabledRules[mode].borderColorFocus
    },
    '&[data-disabled]:hover': {
      backgroundColor: disabledRules[mode].backgroundColorHover
    },
    '&[data-invalid]': {
      backgroundColor: invalidRules[mode].backgroundColor,
      borderColor: invalidRules[mode].borderColor
    },
    '&[data-invalid]:focus-within': {
      backgroundColor: invalidRules[mode].backgroundColorFocus,
      borderColor: invalidRules[mode].borderColorFocus
    },
    '&[data-invalid]:hover': {
      backgroundColor: invalidRules[mode].backgroundColorHover
    }
  };
};

var widthMap = {
  xsmall: 80,
  small: 160,
  medium: 240,
  large: 320,
  xlarge: 480
};

var getMaxWidth = function getMaxWidth(width) {
  return !width ? "100%" : width in widthMap ? widthMap[width] : +width;
};

var containerStyles = function containerStyles(appearance, mode, width) {
  return _objectSpread(_objectSpread({
    alignItems: 'center'
  }, getContainerTextBgAndBorderColor(appearance, mode)), {}, {
    borderRadius: 3,
    borderWidth: 2,
    borderStyle: appearance === 'none' ? 'none' : 'solid',
    boxSizing: 'border-box',
    display: 'flex',
    flex: '1 1 100%',
    fontSize: fontSize,
    justifyContent: 'space-between',
    maxWidth: getMaxWidth(width),
    overflow: 'hidden',
    transition: "background-color 0.2s ease-in-out, border-color 0.2s ease-in-out",
    wordWrap: 'break-word',
    verticalAlign: 'top',
    pointerEvents: 'auto'
  });
};

exports.containerStyles = containerStyles;

var inputStyles = function inputStyles(mode) {
  return {
    backgroundColor: 'transparent',
    border: 0,
    boxSizing: 'border-box',
    color: 'inherit',
    cursor: 'inherit',
    fontSize: fontSize,
    minWidth: '0',
    outline: 'none',
    width: '100%',
    lineHeight: gridSize * 2.5 / fontSize,
    fontFamily: (0, _constants.fontFamily)(),
    '&[data-monospaced]': {
      fontFamily: (0, _constants.codeFontFamily)()
    },
    '&[data-compact]': {
      padding: "".concat(gridSize / 2, "px ").concat(gridSize - 2, "px"),
      height: "".concat((gridSize * 3.5 / fontSize).toFixed(2), "em")
    },
    '&:not([data-compact])': {
      padding: "".concat(gridSize, "px ").concat(gridSize - 2, "px"),
      height: "".concat((gridSize * 4.5 / fontSize).toFixed(2), "em")
    },
    '&[disabled]': {
      // Safari puts on some difficult to remove styles, mainly for disabled inputs
      // but we want full control so need to override them in all cases
      WebkitTextFillColor: 'unset',
      WebkitOpacity: 1
    },
    // Hide the clear indicator on Edge (Windows only)
    '&::-ms-clear': {
      display: 'none'
    },
    '&:invalid': {
      boxShadow: 'none'
    },
    '&::placeholder': {
      color: componentTokens.placeholderTextColor[mode],
      '&:disabled': {
        color: disabledRules[mode].textColor
      }
    }
  };
};

exports.inputStyles = inputStyles;
var TextFieldColors = {
  backgroundColor: backgroundColor,
  backgroundColorFocus: backgroundColorFocus,
  backgroundColorHover: backgroundColorHover,
  borderColor: borderColor,
  borderColorFocus: borderColorFocus,
  placeholderTextColor: componentTokens.placeholderTextColor,
  textColor: componentTokens.textColor,
  invalidRules: invalidRules,
  disabledRules: disabledRules
};
exports.TextFieldColors = TextFieldColors;