import _extends from "@babel/runtime/helpers/extends";
import _typeof from "@babel/runtime/helpers/typeof";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/** @jsx jsx */
import React, { forwardRef, memo, useCallback, useMemo, useRef } from 'react';
import { jsx } from '@emotion/core';
import { usePlatformLeafEventHandler } from '@atlaskit/analytics-next';
import GlobalTheme from '@atlaskit/theme/components';
import { containerStyles as getContainerStyles, inputStyles as getInputStyles } from './styles';
var analyticsParams = {
  componentName: 'textField',
  packageName: "@atlaskit/textfield",
  packageVersion: "5.0.1"
};
var TextfieldWithMode = /*#__PURE__*/forwardRef(function (props, ref) {
  var input = useRef(null);

  var _props$appearance = props.appearance,
      appearance = _props$appearance === void 0 ? 'standard' : _props$appearance,
      _props$isCompact = props.isCompact,
      isCompact = _props$isCompact === void 0 ? false : _props$isCompact,
      _props$isDisabled = props.isDisabled,
      isDisabled = _props$isDisabled === void 0 ? false : _props$isDisabled,
      _props$isInvalid = props.isInvalid,
      isInvalid = _props$isInvalid === void 0 ? false : _props$isInvalid,
      _props$isRequired = props.isRequired,
      isRequired = _props$isRequired === void 0 ? false : _props$isRequired,
      _props$isReadOnly = props.isReadOnly,
      isReadOnly = _props$isReadOnly === void 0 ? false : _props$isReadOnly,
      _props$isMonospaced = props.isMonospaced,
      isMonospaced = _props$isMonospaced === void 0 ? false : _props$isMonospaced,
      width = props.width,
      mode = props.mode,
      elemAfterInput = props.elemAfterInput,
      elemBeforeInput = props.elemBeforeInput,
      testId = props.testId,
      onFocus = props.onFocus,
      onBlur = props.onBlur,
      onMouseDown = props.onMouseDown,
      className = props.className,
      otherProps = _objectWithoutProperties(props, ["appearance", "isCompact", "isDisabled", "isInvalid", "isRequired", "isReadOnly", "isMonospaced", "width", "mode", "elemAfterInput", "elemBeforeInput", "testId", "onFocus", "onBlur", "onMouseDown", "className"]);

  var handleOnFocus = usePlatformLeafEventHandler(_objectSpread({
    fn: function fn(event) {
      onFocus && onFocus(event);
    },
    action: 'focused'
  }, analyticsParams));
  var handleOnBlur = usePlatformLeafEventHandler(_objectSpread({
    fn: function fn(event) {
      onBlur && onBlur(event);
    },
    action: 'blurred'
  }, analyticsParams));
  var handleOnMouseDown = useCallback(function (event) {
    /** Running e.preventDefault() on the INPUT prevents double click behaviour */
    // Sadly we needed this cast as the target type is being correctly set
    var target = event.target;

    if (target.tagName !== 'INPUT') {
      event.preventDefault();
    }

    if (input && input.current && !isDisabled && document.activeElement !== input.current) {
      input.current.focus();
    }

    onMouseDown && onMouseDown(event);
  }, [onMouseDown, input, isDisabled]); // we want to keep a copy of the ref as well as pass it along

  var setInputRef = useCallback(function (inputElement) {
    input.current = inputElement;
    var forwardedRef = ref;

    if (!forwardedRef) {
      return;
    }

    if (_typeof(forwardedRef) === 'object') {
      // This is a blunder on the part of @types/react
      // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/31065
      // .current should be assignable
      // @ts-ignore
      forwardedRef.current = inputElement;
    }

    if (typeof forwardedRef === 'function') {
      forwardedRef(inputElement);
    }
  }, [ref]);
  var inputControlProps = {
    'data-compact': isCompact ? isCompact : undefined,
    'data-monospaced': isMonospaced ? isMonospaced : undefined,
    'aria-invalid': isInvalid ? isInvalid : undefined
  };
  var containerControlProps = {
    'data-disabled': isDisabled ? isDisabled : undefined,
    'data-invalid': isInvalid ? isInvalid : undefined
  };
  var containerStyles = useMemo(function () {
    return getContainerStyles(appearance, mode, width);
  }, [appearance, mode, width]);
  var inputStyle = useMemo(function () {
    return getInputStyles(mode);
  }, [mode]);
  return (// https://product-fabric.atlassian.net/browse/DST-1970
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions
    jsx("div", _extends({}, containerControlProps, {
      onMouseDown: handleOnMouseDown,
      "data-ds--text-field--container": true,
      "data-testid": testId && "".concat(testId, "-container"),
      css: containerStyles,
      className: className
    }), elemBeforeInput, jsx("input", _extends({}, otherProps, inputControlProps, {
      disabled: isDisabled,
      readOnly: isReadOnly,
      required: isRequired,
      onBlur: handleOnBlur,
      onFocus: handleOnFocus,
      ref: setInputRef,
      "data-ds--text-field--input": true,
      "data-testid": testId,
      css: inputStyle
    })), elemAfterInput)
  );
});
var Textfield = /*#__PURE__*/forwardRef(function Textfield(props, ref) {
  return jsx(GlobalTheme.Consumer, null, function (_ref) {
    var mode = _ref.mode;
    return jsx(TextfieldWithMode, _extends({}, props, {
      mode: mode,
      ref: ref
    }));
  });
});
Textfield.displayName = 'Textfield';
export default /*#__PURE__*/memo(Textfield);