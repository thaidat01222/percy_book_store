"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSizeStyles = exports.getSVGStyles = void 0;

var _taggedTemplateLiteral2 = _interopRequireDefault(require("@babel/runtime/helpers/taggedTemplateLiteral"));

var _core = require("@emotion/core");

var _constants = require("../constants");

function _templateObject() {
  var data = (0, _taggedTemplateLiteral2.default)(["\n  overflow: hidden;\n  pointer-events: none;\n  color: ", ";\n  fill: ", ";\n\n  /**\n  * Stop-color doesn't properly apply in chrome when the inherited/current color changes.\n  * We have to initially set stop-color to inherit (either via DOM attribute or an initial CSS\n  * rule) and then override it with currentColor for the color changes to be picked up.\n  */\n  stop {\n    stop-color: currentColor;\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

var getSVGStyles = function getSVGStyles(_ref) {
  var primaryColor = _ref.primaryColor,
      secondaryColor = _ref.secondaryColor;
  return (0, _core.css)(_templateObject(), primaryColor || 'currentColor', secondaryColor);
};
/**
 * Returns the width of the icon's parent span. This function has
 * special behaviour to deal with icon-file-type specifically.
 *
 * The reality is the SVG still has its own dimensions, so this is
 * a secondary fallback which in 95% of cases is not required.
 * It's only really being kept to maintain backward compatability.
 */


exports.getSVGStyles = getSVGStyles;

var getSizeStyles = function getSizeStyles(_ref2) {
  var width = _ref2.width,
      height = _ref2.height,
      size = _ref2.size;

  if (width && height) {
    return "height: ".concat(height, "px; width: ").concat(width, "px;");
  }

  if (size) {
    return "height: ".concat(_constants.sizes[size], "; width: ").concat(_constants.sizes[size], ";");
  }

  return '';
};

exports.getSizeStyles = getSizeStyles;